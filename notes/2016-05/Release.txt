[ ] BUG: Fix audio not working in standalone executable!


[ ] Implement the larger scene plan with
        [x] Sequencer room
                Playheads could have handles they move relative to so they could be picked up and moved
                Play/pause? Or just code it as demo
                Precompose some sequences and then duplicate the playhead and carry it over to the next sequence
                to increase intensity of music
                    (maybe need to think of how to quantize/synchronize playheads effectively;
                    have handle snap-to-grid on release?)
                Could do sampler here too

        [ ] Tutorial room
                Pedastal sequence of how to use rumpus (or should this be in the main room)
                then how to build things in the language,
                how to add sound, how to add physics
                Game of life sim?
                Volume helmet?
        [ ] Shooter game room
        [ ] Outdoor patio
                This holds a city builder and demos editing of a large scale environemnt
                Animated windows turning on and off, stars in the sky.


[x] Teleporting!
        [x] I think I like predefined teleport balls that exist in each room when you're not in them.

        We want to move the player's view and hands, not the world,
        so just add that to the hands and head when updating them

[ ] Entity registry for non-local communication making scoreboards etc.
    registerName "scoreboard"
    getEntityNamed "scoreboard"
    getScriptDataNamed "scoreboard"

[x] SteamVR keyboard

[ ] Framerate pass
        Consider how hard doing a basic multithreaded renderer would be... could be great!!
        [i] Seems to be much better since fixing the error renderers recreating themselves
            on each keypress!

[ ] Audio latency pass

[x] BUG: Fix OpenAL Invalid Operation

[ ] Try to rebuild space pirate trainer! Use that to inform further improvements...
	[ ] Object-to-hand attachment
		Grip Button? Move teleport to above thumbpad.
        Could be grip button only when already holding, then grip again to release?
        That way I don't have to tell people "put it down then grab it again with the grip button",
        but rather the grip button is like a lock. Or maybe just make sure grip works when already holding with trigger?

[x] Simplify language

        Use tutorial as an opportunity to simplify lang examples as much as possible
        e.g. pull out 'align-vector-to-entity' code from fountain; we'll need it for guns!
        should mySize etc. be selfSize or cSize or eSize or thisSize or
        s'size e_color?

        s'size  ==> V3 1 2 4
        s'color ==> V3 1 2 4
        e'color ==> V3 1 2 4
        s_size  ==> V3 1 4 5
        e_size  ==> V3 1 2 4
        e_color ==> V3 1 2 4
        pColor  ==> V3 1 3 2
        eColor  ==> V4 1 3 2 5
        eSize   ==> V3 1 3 2 -- I think I like eNames best, they feel friendly and Haskelly. As does ==>. := looks too other-languagey.

        Think of what protection we can put in for users - we can protect against exceptions easily enough,
        but non-termination is a little more difficult.
        An idea: run the code in a thread sandbox for a single frame and deny it if it takes longer than 10ms??
            That would be preeeeetty cool and helpful even when coding intelligently to force VR compatability : ))
            Obviously this won't help once you start forking off your own threads but at that point you're advanced
            enough that it's OK!

[x] Object duplication
        If holding with one hand, grab with other hand and pull out a copy. Simple!
        [x] Figure out getting new instance of code.
        	Should copy the CompiledValue from the CodeEditor to avoid delay when cloning.
	        Name by just incrementing a counter?
	        Put the name on one side of the cube??
        [x] "Make Independent" option after cloning that does the copying of the code files.
            I think this fits what you'd want most of the time?
            E.g. in the sequencer I definitely want all notes to share behavior,
            and when spawning a new object (e.g. a bullet) we want to share behavior.

[x] Blank object creation

[ ] Fix undo, check if it was the culprit in causing judder and switch design if so

[ ] Object & scene management
		Swipeable button to access advanced features? Swipe to the button you want and then click down?
		Or do SPT-style menu?
		Obviously find way to make hand editable so we can implement new hands while inside
		Delete with a laser ray that slowly vaporizes the object so you can change your mind
		Blank object creation
		Open object library
		Multiselect by swiping through a bunch of objects or lasering
		Play/Pause

[x] Fix mirror window
    Go fullscreen by default and set GLFW_CURSOR_DISABLED for VR (and GLFW_CURSOR_HIDDEN for nonVR? we want the window-bounding but no cursor)

[ ] A few more object types: whatever bullet makes easy. Cone, tetra, pyramid, cylinder, capsule, etc.
		(btConvexHullShape should do the trick for polyhedra!)

[ ] BUG: Collisions always pass 0.1 for their impulse strength. Why's it hard to get?

Later thoughts:
- Clean up GLFW gamepad API for local multiplayer games!
- Think about registering components at runtime in user scripts.
	This would be probably handier than the ScriptData system.
    (Perhaps just have files that are automatically loaded like a Types.hs?)

- "Slow Start" facility for objects that spawn a lot of children - limit the number they can spawn per frame
- and spread it out over many frames instead. Slow way down to look awesome; watch the algorithm build the work.

- Look-to-set-cursor on touchpad - hold a button, and a beam comes out of your forehead?
    (basically, raycast along headpose, get hit point, then move up from head and orient a line down to the hitpoint.)

- Top Level Definition Parsing:
    Fun ideas with top-level definitions!!!

    Parse top-level definitions like x = 40.

    Two things we can do with that:
    One, we can turn them into automatic interfaces for the object - e.g. sliders along the side, or levers coming out of the code, etc.
    Two, we can replace the YAML storage with just writing values directly into the file. It'll be super easy since we just need to check the starts of each line.


- Use OpenVR's Submit_GlRenderBuffer
    (does this mean we don't do the blit-to-texture ourselves, and let OpenVR handle that? I think that's what they mean.)


- Idea for making GPU handle transform stacks:
    Pass a list of indices into an M44 buffer that the shader should look up to assemble into the actual model transform.
    This requires keeping all transforms in one buffer and dealing with whatever rejiggering that causes.
    (Remember this should be in a compute/geo shader, we don't want to run on every vertex)

    Look up "skeletal animation" to see more approaches
        "Also uniform buffers can be used to store the matrices of bones and use them for implementing skeletal animation, however, I personally prefer using normal 2D textures for this purpose to take advantage of the free interpolation thanks to the dedicated texture fetching units but thatâ€™s another story."
        http://rastergrid.com/blog/2010/01/uniform-buffers-vs-texture-buffers/
