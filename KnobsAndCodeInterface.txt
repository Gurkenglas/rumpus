        These could automatically lay themselves out on the object's control panel.


        addQuickKnob "Scale" 0 10 50 setSize
        tickKnobSystem

        for a knob that automatically calls setSize.
        Takes any (Float -> EntityMonad) function.
        Can always expose a more explicit version with a readKnob function
            scaleKnob <- quickKnob "Scale" 0 10 50
            myUpdate ==> do
                setSize =<< readKnob scaleKnob
        for using in myUpdate etc.
        This could be the basis of an easy FRPish system;
        addModulator SineWave 0.1 2 (10::Seconds) setSize

        The control panel would house the keys

         O      O     O      O
        size  shape  color  rate
[][][][]|                       |[][][][]
[][][][]|                       |[][][][]
[][][][]|                       |[][][][]
[][][][]|                       |[][][][]
[][][][]|                       |[][][][]
[][][][]|                       |[][][][]


        Code should be small but legible til you click on it.
        |     |
        |_____|
          [~]
        click on [~] to expand keyboard etc.




[ ] ConsoleSystem that encompasses screen, keys and knobs

        Consoles start out as mini-computers that are attached to the object
        Click on them to make them full size, bring up knobs, etc.

        At full size, they still default to being attached to their object(?)
        Pull them away and they become strung-out from their object,
        with a connecting wire. You can dock them again by dragging them back, or
        just click away from them.

        In this way you can remote-control code from anywhere,
        and this gives a good option for plucking objects out of the library to edit.

        You can grab either from your inventory:
        BACKPACK
        [Object][Code]
        [Object][Code]
        [Object][Code]
        (Ah, maybe there's something here for instance vs. copy!
        grab object to make an instance, duplicate code to make copy?)

        Throw console with enough velocity to dismiss it

[ ] Buttons and toggles as well as knobs, to make it easy to
    do things like add a button to toggle Floating.

[ ] Add letter-to-buffer animation where they fly off the keyboard (add a grey version for immediate feedback)
