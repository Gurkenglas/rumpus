Get rid of withSystem in favor of viewSys â€” it's ok to crash on a missing system.
(think about this a bit more; I feel like I always regret introducing partial functions...)

- Syntax ideas:

dynamicsWorld <- viewSystem sysPhysics psDynamicsWorld
dynamicsWorld <- view psDynamicsWorld <$> viewSystem sysPhysics
dynamicsWorld <- sysPhysics >. psDynamicsWorld

audit for uses of withSystem to make sure modifySystem wasn't meant instead



Need to support:
- [ ] EntityLibrary with spawning by name, and optional persistence
      (An entity template is a Vault? A (Map String Value)? 
      Don't want to pay deserialization cost...)
- [ ] Saving entities and scenes (with references to entities)
- [ ] Associated components, e.g. mass with rigidbody, delete the rigidbody and autodelete mass too?


- Move Selection to its own system so CodeEditor and SceneEditor can use it

- Add FocusedCodeEditor to CodeEditor to use rather than selectedEntity

- PlayPause -> System?




- Use the Hspec-discover http://hspec.github.io/hspec-discover.html method of 
    {-# OPTIONS_GHC -F -pgmF hspec-discover #-}
  (i.e. write rumpus-discover)
  to find all the systems in e.g. app/Systems, and thus register them with the system.
  Use a graph representation to define dependencies




Must distinguish between derived and persistent properties.
E.g. rigidBody, animation, codeEditor, etc. are derived.
We need a descriptor for animations.

We also want a way to define a default set of properties.
Size, Color, Position, Shape (eventually, Shader)

These should be the properties added to a brand new object.

How to add an animation of an arbitrary property (e.g. a uniform?)
(rethink from start what an animation is; include infinite sines)

We also want to be able to clone named entities.
A library of Map Name Vault would be good here,
where the Vault in this case either uses special keys to Component types,
or reuses the Key (EntityMap ComponentFoo) with a single entityID.
Must be able to "resuscitate" these inert entities, 
which should consist only of persistent properties,
into living entities again. E.g. adding a rigidBody.


This should probably piggyback on a system that always adds derived properties from inert at the moment of addition.


So e.g.

ciActivateComponent = \entityID -> do
    shape <- getShapeType entityID
    shapeCollider <- makeShapeCollider shape
    rigidBody <- createRigidBody shapeCollider
    addRigidBody dynamicsWorld rigidBody

