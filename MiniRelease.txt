[ ] Fix audio on release builds! Try updating to latest OpenAL! That could be the difference
    (more path stuff, our OpenAL being overridden...)

[ ] Finish keyboard
[ ] Add exception handler to update and start functions. See older cubensis code for instructions..

[ ] Add microphone-reactive object
[ ] Create intro object
        TRY EDITING ME
[ ] Build city


[x] Find Windows documents directory, copy scenes there and load from there
    getUserDocumentsDirectory
    copy scenes 

[ ] Add Tab and Shift-Tab support to freetype-gl-mini (only operates on beginning of line, insert or remove 4 spaces, easy : ))


[x] Finish faster code-update system.
        Basic idea: we want to pass char buffers to the GHC API.
        Maybe premature optimization, but could have TextBuffer store each line in parallel as a char buffer and a Seq, 
        rebuilding the char buffer on each change to a line, and just gluing the buffers together when dumping its contents as a single char buffer.

        While passing it off, also save the file on a background queue thread.
        We also want to pause the file watcher while we save our version of the file so it doesn't resubmit it for recompilation.

        Right now, have selected code hook into CodeEditor and pass a String to Halive via a CompilationRequest. 
        Disable code loading from files to ensure that this fixes things, then implement the filewatcher pausing.
        Switch file saving to be async.

        [ ] I've commented out refreshTextRendererFromFile in CodeEditor.hs:264
            (since it's the cause of the pauses while typing!) while I figure out
            the right way to refresh the text - should do the readFile call 
            in the background upon receiving the FileEvent, but also want to be able
            to pause that when we are making edits.

            (something something file modification date?? How to communicate this to this different bits though...)




import Rumpus

-- This is the code that generates the shape you see above.

-- These variables change how the object looks and behaves
rotationSpeed = 1

-- Try changing the colors!
objectColor = colorRGB (1,2,3)

-- Here's where we actually set up the object!
start = do
    myColor ==> objectColor

    -- This is the "Update" function, which gets run 90 times per second to
    -- to define how the object behaves.
    -- In this case, we're having the object change 
    -- its rotation and color 
    -- based on what time it is.
    myUpdate ==> do
        now <- getNow
        myPose ==> toPose def { posePosition = V3 0 1 0
                              , poseOrientation = axisAngle (V3 0 1 0) (now * rotationSpeed) 
                              }

