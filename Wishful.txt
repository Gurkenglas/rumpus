








prototype 


entity 
    [ pose
    , shape
    , size
    , color
    , renderable Transparent
    , physics
    , attachment entityID offset
    , attractor radius
    ]



attractorSystem = do
    forM attractors $ \(entityID, Attractor radius) -> do
        position <- use (poses . at entityID . posPosition)
        nearbyIDs <- findEntitiesWithin radius position


attach entityID toEntityID = do
    findOffset entityID toEntityID
    attachments . at entityID ?= Attachment toEntityID offset


attachmentsSystem = do
    forM attachments $ \(entityID, Attachment toEntityID offset) -> do
        pose <- use (poses . at entityID)
        poses . at toEntityID ?= pose + offset


physicsSystem = do


syncPhysicsPosesSystem = do



-- Here we sketch an extensible component system...


data Physics = Physics { phyRigidBody :: RigidBody , phyGhost :: GhostObject }
newtype PhysicsMap = PhysicsMap { unPhysicsMap :: EntityMap Physics }
makeClassy ''PhysicsMap


newtype ShapeMap = ShapeMap  { unShapeMap :: EntityMap Shape }
makeClassy ''ShapeMap
newtype PoseMap  = PoseMap   { unPoseMap  :: EntityMap Pose }
makeClassy ''PoseMap
newtype ColorMap  = ColorMap { unColorMap  :: EntityMap Color }
makeClassy ''ColorMap




data RenderResources = RenderResources 
    { rstProj44 :: M44
    , rstViewM44 :: M44
    , rstShapes :: [(ShapeType, Shape)] 
    }

renderSystem :: ( HasRenderResources r
                , HasPoseMap r
                , HasShapeMap r
                , HasSizeMap r
                , HasColorMap r
                , MonadReader r m, MonadIO m) => m ()
renderSystem = do
    projM44 <- view rstProjM44
    viewM44 <- view rstViewM44



{- 
How does this work with dynamically creating new systems? Does it? I don't think so...
We can't call a "createSystem" command with all those types in the way.
How would the system dynamically modify the Component DB with the new rows it needs?


IntMap ComponentID Component?

myComponentID <- registerComponent myComponent
^ rather than string lookups...

Punt on extensible systems and just use scripts? 
Scripts still need state data... 
but the dynamic approach is OK there...
-}


registerSystem :: (Dynamic a) => 
registerSystem "fftSystem" (Dynamic )


data System = System { _sysState :: Dynamic, sysUpdate :: Dynamic -> WorldMonad () }

type SystemsStates = Map SystemName System

tickSystems = do
    systemStates <- Map.toList use wldSystemStates
    forM_ systemStates \(systemName, System{..}) -> do
        newState <- (system ^. sysUpdate) (system ^. sysState)
        wldSystemState . at systemName . sysState ?= newState

{- ^^^^^^
Sketch of a dynamic systems system.
sysUpdate functions could reference the state of other systems by just querying e.g.
physicsSystemState <- fromDyn (use (wldSystemState . at "physicsSystem"))

Maybe we can get stable Integer ComponentIDs by doing some kind of...
{-# NOINLINE physicsSystemID #-}
physicsSystemID = unsafePerformIO getNextSystemID

http://apfelmus.nfshost.com/blog/2011/09/04-vault.html
(also see comments for lots of ideas on alternative implementations!)
Ooh, this might be great.


Can provide the keys of the default system like 
BuiltinKeys { bikPhysicsKey :: Key PhysicsComponents, bikPdKey :: Key PdComponents, etc. }

or, maybe better, use the trick above to say:
{-# NOINLINE physicsSystemID #-}
physicsSystemID :: Key PhysicsComponents
physicsSystemID = unsafePerformIO newKey

We can store the systems' static data in the same way (e.g. dynamicsWorld, shapes, etc.)
And then hopefully we can separate everything out into modules...


Is this any improvement over just using a ton of global IORefs??
I guess one thing Heinrich had in mind with Vault is that it's immutable, 
and can thus be captured as an atomic whole, so that's something...






More thoughts.
Can replace current Entity struct with just a Map Text Value
We'll make this a lazy Map such that the actual values are (encodeJSON value),
thus deferring the serialization overhead until we actually write the thing to disk

Systems will then have an "addComponent entityID componentName" call that gets triggered when deserializing an entity, 
which they can match on to add a component if it matches their own componentName.

-}
